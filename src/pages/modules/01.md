---
layout: layouts/views/general.njk
title: Perceptrón booleano
---

# Módulo 1 – Perceptrón Booleano

## Introducción

¿Listo para desarmar una neurona artificial y ver de qué está hecha?

Verás que no tiene tantos secretos. Solo unas cuantas piezas básicas que, colocadas en orden, pueden aprender a tomar decisiones.

Si vamos a entrenar una operación lógica, es obvio que necesitamos algo que se comporte de manera similar. Por eso, nuestra neurona tendrá dos entradas y una salida.

Además de esos elementos externos, vamos a definir su funcionamiento interno. Estos son:

- Una lista de pesos según la cantidad de entradas. Estos, junto con el sesgo (un valor extra que aprenderás enseguida), serán los responsables de definir el comportamiento de la neurona. Todo depende de los valores que tengan.
- Una función de ponderación. Se encarga de multiplicar cada entrada por su peso y luego sumar esos resultados con el sesgo.
- La función de activación. Esta generará el número que irá en la única salida según el resultado de la ponderación.

Nada más. Así de simple.

---

Ahora sí, abre tu editor de código y vamos a programar:

Una neurona puede tener cualquier cantidad de entradas. Para nuestro perceptrón booleano vamos a usar dos, así que vamos a crearlas en el editor escribiendo:

``` C
int Entrada_1;
int Entrada_2;
```

La instrucción int nos permite crear una variable que contendrá un número entero. Esta variable tendrá el nombre que le asignemos a la derecha de int, en nuestro caso: las variables Entrada_1 y Entrada_2.

Al final de cada línea se usa el carácter ;, que indica que la instrucción ha terminado. No tardarás mucho en darte cuenta de su importancia: si olvidas un punto y coma, el compilador te avisará con un error.

Siguiendo el proceso anterior, vamos a crear la variable de salida:

``` C
int Entrada_1;
int Entrada_2;

int Salida;
```

La salida será el resultado final de la neurona, es decir, la respuesta que obtendremos después de hacer los cálculos.

¿Ves qué sencillo es crear los elementos que componen la neurona?

Ahora, según la lista de ingredientes del inicio, necesitamos una lista de pesos, uno por cada entrada, además de un sesgo:

``` C
int Entrada_1;
int Entrada_2;

int Salida;

float Peso_1;
float Peso_2;

float Sesgo;
```

¿Qué ha pasado aquí?
Ya no usamos int, ahora hemos usado la instrucción float. No te asustes: funciona de manera parecida a int, pero float se usa cuando la variable puede tener valores con punto decimal.
Por ejemplo, podrías usarlo para guardar números como 0.5 o 1.25.

Los pesos y el sesgo suelen necesitar valores decimales para poder ajustar con más precisión el comportamiento de la neurona.

Ya tienes los elementos. Ahora hay que definir cómo se relacionan entre sí. En otras palabras, el comportamiento de la neurona.

Para hacer esto, vamos a conocer un elemento más del lenguaje C: la función main. Este será el espacio donde irán las instrucciones que le pediremos a la computadora que ejecute.

Para crear la función main, solo es necesario declararla:

``` C
int Entrada_1;
int Entrada_2;

int Salida;

float Peso_1;
float Peso_2;

float Sesgo;

int main(){}
```

Antes de continuar, hagamos una pequeña pausa para aclarar un par de cosas importantes.

Primero: ¿por qué la función main es tan especial?
En cualquier programa escrito en C, siempre debe existir una función llamada main. Puedes pensar en ella como el punto de inicio: cuando ejecutas tu programa, el sistema operativo entra por esa puerta y empieza a recorrer las instrucciones que encuentre dentro, de arriba hacia abajo.
Cuando se llega al final de las instrucciones dentro de main, el programa termina. No importa cuántas otras funciones o variables declares: sin main, nada sucede.

Ya tienes tu código con las variables y la función main. Es momento de compilarlo. Si nunca habías escuchado esa palabra, no te preocupes: compilar significa traducir tu código (que escribiste en un lenguaje que tú puedes leer) y crear un nuevo archivo de instrucciones representadas por secuencias de 1 y 0 que la computadora pueda entender.

Si estás usando Code::Blocks, compilar y ejecutar es tan sencillo como hacer clic en el botón de “Build and Run” (o presionar F9). El programa se encargará automáticamente de convertir tu código en un ejecutable y de lanzarlo.

Sea cual sea el método, el resultado será el mismo: se generará un programa que, al ejecutarse, creará en memoria las variables que declaraste y entrará en la función main.
Pero como todavía no escribiste ninguna instrucción dentro, el programa no hará absolutamente nada: simplemente creará esos elementos, los guardará un instante y terminará la ejecución destruyéndolos al salir de main.

Ahora que tienes un mejor entendimiento sobre qué hace main, vamos a describir el comportamiento de la neurona.

Primero haremos el proceso de ponderación, que va a asociar cada entrada con su respectivo peso mediante una multiplicación, y combinará los productos de estas operaciones mediante una sencilla suma. A este resultado se le suma el valor del sesgo. La operación se vería algo así: (E1 x P1) + (E2 x P2) + ... + Sesgo.

``` C
int Entrada_1;
int Entrada_2;

int Salida;

float Peso_1;
float Peso_2;

float Sesgo;

int main(){
    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
}
```

Algunas cosas que debes notar aquí:

- El operador * se usa para indicar una multiplicación. No se utiliza una “x” porque podría confundirse con una letra.
- El resultado de la operación se guarda en una variable de tipo float llamada ponderacion, usando el operador =, que asigna ese valor a la variable.
- Recuerda el uso del carácter ; al final de la instrucción. No lo olvides.

Ahora agreguemos la última pieza: la función de activación. Esta recibe el resultado de la ponderación, aplica una operación matemática y devuelve un nuevo valor.

Existen muchas funciones de activación, pero para nuestro perceptrón booleano usaremos la más sencilla: una función que regresa un 1 si el resultado de la ponderación es mayor o igual que 0, y devuelve un 0 si el resultado es menor que 0.

``` C
int Entrada_1;
int Entrada_2;

int Salida;

float Peso_1;
float Peso_2;

float Sesgo;

int main(){
    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;
}
```

Hemos terminado nuestra neurona. Podemos compilar y ejecutar el programa...

¿Qué ha sucedido? ¿Nada? No exactamente. En realidad, se han ejecutado todas las instrucciones: primero se calcula la ponderación, luego se evalúa el resultado comparándolo contra 0 usando el operador >=, y finalmente se guarda esa respuesta en la variable Salida.

En este caso, ya no es necesario volver a escribir el tipo de dato de Salida porque lo declaraste arriba como int.

Todo esto ocurrió dentro del programa, pero aún no vimos nada porque todavía no le hemos dado ninguna instrucción para que nos muestre información en pantalla.
Aquí es donde vamos a conocer algunas características más del lenguaje C. Vamos a agregar un par de líneas a nuestro código:

``` C
#include <stdio.h>

int Entrada_1;
int Entrada_2;

int Salida;

float Peso_1;
float Peso_2;

float Sesgo;

int main(){
    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "Hola mundo" );
}
```

Vuelve a compilar y ejecutar. Ahora verás el mensaje Hola mundo en la pantalla.

Seguramente ya has deducido qué hace printf, pero hagamos la explicación más clara:

El mensaje “Hola mundo” es una tradición que se usa como primera prueba en casi cualquier lenguaje de programación.

printf es una función, igual que main. Su trabajo es mostrar en pantalla el contenido que escribas entre comillas dentro de sus paréntesis.
Pero esta función no forma parte del lenguaje C de manera nativa. Su comportamiento está definido dentro de una biblioteca llamada stdio.h.

Para poder usarla, primero debes indicarle al compilador que incluya esa biblioteca en tu programa. Eso se hace con esta instrucción:

#include <stdio.h>

Una biblioteca no es más que una colección de funciones listas para resolver necesidades específicas. En este caso, stdio.h contiene varias funciones que tienen que ver con la entrada y salida de información, y una de ellas es printf, que permite mostrar mensajes en pantalla.

Ahora que tu programa tiene la posibilidad de mostrarte información, vamos a aprovecharlo para leer el valor de las variables.
Te mostraré algunos trucos que puedes hacer con la función printf.

Empecemos con algo simple: leer el valor de la salida de la neurona.
Vamos a modificar printf de esta forma:

``` C
#include <stdio.h>

int Entrada_1;
int Entrada_2;

int Salida;

float Peso_1;
float Peso_2;

float Sesgo;

int main(){
    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "%i" , Salida );
}
```

Compila y ejecuta el programa otra vez...

Verás que ahora aparece un número: 0 o 1. Este número es el que está guardado en la variable Salida, y es el resultado de las operaciones que le anteceden.

Esto ocurre porque el símbolo de formato % le indica a printf que lo que sigue es una instrucción especial y no un texto literal.
En este caso, %i significa: “imprime aquí un número entero”.

Después de las comillas, se coloca una coma y se indica qué variable debe imprimirse en ese espacio que definimos.

Ahora vamos a agregar un poco más de información al mensaje de salida:

``` C
#include <stdio.h>

int Entrada_1;
int Entrada_2;

int Salida;

float Peso_1;
float Peso_2;

float Sesgo;

int main(){
    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "Entrada 1: %i , Entrada 2: %i = Salida: %i\n" , Entrada_1 ,  Entrada_2 , Salida );
}
```

Si comparas este último ejemplo con el anterior, verás que ahora no estamos imprimiendo una sola variable, sino varias.
Para hacerlo, simplemente añadimos más caracteres de formato %i dentro del texto entre comillas, separados por texto normal si lo deseas (por ejemplo, para poner etiquetas como “Entrada 1” o “Salida”).

Después de las comillas, se colocan las variables correspondientes en el mismo orden en que aparecerán en el texto resultante, separadas por comas.
Es decir, la primera variable ocupará la primera instrucción de formato %i, la segunda la segunda, y así sucesivamente.

Además, al final del texto agregamos \n. Este es un carácter especial que significa “salto de línea”.
Cada vez que printf llega a \n, baja el cursor a la línea siguiente, sería como presionar la tecla Enter.
Así, si el programa imprime varios resultados, cada uno aparecerá ordenado en su propia línea.

Existen otros caracteres especiales (como \t para tabulaciones, por ejemplo), pero de momento solo vamos a usar \n.

Empecemos a definir el comportamiento de la neurona. Para esto, vamos a manipular los valores de los pesos y el sesgo para simular el funcionamiento de una operación OR, y también vamos a ingresar los valores en las entradas que la neurona usará para hacer el cálculo:

``` C
#include <stdio.h>

int Entrada_1= 0;
int Entrada_2= 0;

int Salida;

float Peso_1= 1;
float Peso_2= 1;

float Sesgo= -1;

int main(){
    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "Entrada 1: %i , Entrada 2: %i = Salida: %i\n" , Entrada_1 ,  Entrada_2 , Salida );
}
```

Compila y ejecuta…

Ahora ya tienes tu primera neurona que se comporta exactamente como una función OR.
Si vas cambiando los valores de las entradas para cada combinación de la tabla de verdad ([0,0], [0,1], [1,0], [1,1]), verás cómo responde.

Para probar los distintos valores, tendrás que volver a compilar cada vez que modifiques las entradas en el código.

Cuando hayas probado las cuatro combinaciones, verás una impresión similar a la tabla de verdad del OR: las entradas muestran todas las combinaciones posibles, y la salida vale 1 siempre que alguna de las dos entradas sea 1.

Esto ocurre por la combinación de los valores de los pesos (que valen 1) y el sesgo (que vale -1).
No es que tengan que ser necesariamente estos números, sino que cumplen una condición: el sesgo debe tener un valor negativo. De esta manera, cuando ambas entradas valen 0, las multiplicaciones por sus pesos también son 0, haciendo que la ponderación sea igual al sesgo. Al evaluarse en la función de activación, como es menor que 0, devuelve 0.

Pero si alguna de las entradas es 1 o mayor, a la ponderación se le suma el valor correspondiente, haciendo que el resultado sea igual o mayor que 0. En ese caso, la función de activación devuelve 1.

Para que quede más claro cómo funciona, ahora vamos a configurar los valores de los pesos y el sesgo para lograr el comportamiento de la operación NOR:

``` C
#include <stdio.h>

int Entrada_1= 0;
int Entrada_2= 0;

int Salida;

float Peso_1= -1;
float Peso_2= -1;

float Sesgo= 0;

int main(){
    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "Entrada 1: %i , Entrada 2: %i = Salida: %i\n" , Entrada_1 ,  Entrada_2 , Salida );
}
```

Ahora la ponderación puede tomar los valores 0, -1 y -2, según qué entradas estén activadas.
Esto quiere decir que, al evaluar el resultado en la función de activación, la salida será 1 solamente cuando ninguna de las dos entradas esté activada.

Ya has aprendido cómo funciona una neurona artificial: para que se comporte como una operación lógica determinada, solo necesitas establecer los valores de los pesos y el sesgo según ciertas condiciones específicas.
Por ejemplo, si quisieras simular la función AND, deberías asignar un número negativo al sesgo y asegurarte de que cada peso, por sí solo, no logre que la ponderación alcance un valor de 0 o mayor, pero que sí lo consiga con la suma de ambos pesos.
Así, la neurona solo regresará un 1 cuando ambas entradas estén activas y los dos pesos se sumen para vencer al sesgo.

Ya te habrás dado cuenta de que compilar el programa cada vez que cambias los valores de las entradas no es muy práctico.
Ahora vamos a conocer otra función disponible en stdio.h: scanf. Esta función te permite ingresar valores desde el teclado mientras el programa está en ejecución.

Ajusta los valores de los pesos y el sesgo para una operación AND y veamos cómo funciona:
``` C
#include <stdio.h>

int Entrada_1= 0;
int Entrada_2= 0;

int Salida;

float Peso_1= 1;
float Peso_2= 1;

float Sesgo= -2;

int main(){

    printf( "Entrada 1: " );
    scanf( "%i" , &Entrada_1 );
    printf( "Entrada 2: " );
    scanf( "%i" , &Entrada_2 );

    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "Salida: %i\n" , Salida );
}
```

Compila y ejecuta...

Ahora la computadora te pedirá primero los valores de las entradas, una por una, guardará esos valores en sus respectivas variables, realizará el cálculo usando los pesos y el sesgo que definiste, y finalmente mostrará la salida correspondiente.

De esta manera, podrás ejecutar el programa varias veces sin necesidad de recompilar cada vez que quieras probar una combinación distinta de entradas. Solo será necesario compilar si deseas ajustar los pesos o el sesgo para que la neurona se comporte de manera diferente.

No te preocupes por ahora en qué hace el carácter & dentro de la instrucción scanf. Por el momento, solo recuerda que es necesario colocarlo. Más adelante en el curso verás con detalle qué significa y por qué se utiliza.

Ahora te invito a probar qué ocurre si en las entradas colocas valores distintos de 0 o 1. Notarás que la salida puede presentar comportamientos extraños, dependiendo de los valores que hayas definido en los pesos y el sesgo.

Para asegurarnos de que nuestra neurona siempre trabaje con entradas que sean 0 o 1, vamos a añadir un pequeño ajuste al código:

``` C
#include <stdio.h>

int Entrada_1= 0;
int Entrada_2= 0;

int Salida;

float Peso_1= 1;
float Peso_2= 1;

float Sesgo= -2;

int main(){

    printf( "Entrada 1: " );
    scanf( "%i" , &Entrada_1 );
    printf( "Entrada 2: " );
    scanf( "%i" , &Entrada_2 );

    Entrada_1= !!Entrada_1;
    Entrada_2= !!Entrada_2;

    float ponderacion= (Entrada_1 * Peso_1) + (Entrada_2 * Peso_2) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "Salida: %i\n" , Salida );
}
```

Aquí estás conociendo el operador NOT en lenguaje C, que se representa con el signo de exclamación (!).
Lo que hemos añadido son un par de líneas que aplican una doble negación a cada entrada.

La primera negación convierte cualquier valor distinto de cero en 0 (falso) y cualquier cero en 1 (verdadero). La segunda negación invierte ese resultado nuevamente: de esta forma, cualquier número distinto de cero termina transformándose en 1, y el cero permanece como 0.

En resumen, cuando aplicas !! sobre una variable, conviertes cualquier número distinto de cero en 1, y dejas el 0 como 0. Así garantizas que todas las entradas sean estrictamente binarias, logrando un comportamiento más predecible dentro de la neurona.

Es momento de tomar un poco más de control sobre el código. El perceptrón de este ejercicio solo maneja dos entradas, pero ¿te imaginas si tuviera que manejar 10, 20, 100 o hasta miles, con un peso para cada una? Sería demasiado trabajo crear y controlar todas esas variables por separado.

Para resolver esto, vamos a introducir una herramienta más del lenguaje C: los arreglos.

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={1 , 1};

float Sesgo= -2;

int main(){

    printf( "Entrada 1: " );
    scanf( "%i" , &Entrada[0] );
    printf( "Entrada 2: " );
    scanf( "%i" , &Entrada[1] );

    Entrada[0]= !!Entrada[0];
    Entrada[1]= !!Entrada[1];

    float ponderacion= (Entrada[0] * Peso[0]) + (Entrada[1] * Peso[1]) + Sesgo;
    Salida= ponderacion >= 0;

    printf( "Salida: %i\n" , Salida );
}
```

Como ves, ahora ha cambiado la forma en que declaramos y usamos las entradas y los pesos.
Al incluir los corchetes [] después del nombre, indicamos que no se trata de una sola variable, sino de un arreglo. Un arreglo es una colección de variables del mismo tipo y nombre, a las que podemos acceder usando un índice. En C, el primer elemento siempre tiene el índice 0.

En este código se declararon los arreglos de dos maneras distintas:

- Entradas:  
int Entrada[2];  
Aquí indicamos explícitamente que el arreglo tendrá dos posiciones.
- Pesos:  
float Peso[] = {1, 1};  
En este caso, como le estamos asignando los valores en el momento de la declaración, C calcula automáticamente cuántos elementos tiene el arreglo (en este ejemplo, dos).

Cada número entre llaves {} se va asignando en orden a las posiciones del arreglo: el primero ocupa el índice 0, el segundo el índice 1, y así sucesivamente.

Bien, ahora que ya conoces los arreglos, te voy a mostrar una de sus principales fortalezas: la capacidad de seleccionar un elemento mediante un simple número.
Gracias a esto, podemos utilizar un bucle, que es un bloque de instrucciones que se repiten una cantidad determinada de veces, para simplificar aún más nuestro código:

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={1 , 1};

float Sesgo= -2;

int main(){

    for( int i= 0 ; i < 2 ; i= i + 1){
        printf( "Entrada %i: " , i );
        scanf( "%i" , &Entrada[i] );
        Entrada[i]= !!Entrada[i];
    }

    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
    Salida= ponderacion >= 0;

    printf( "Salida: %i\n" , Salida );
}
```

¿Qué se ha hecho aquí?

Se ha aprovechado la propiedad de los arreglos de acceder a sus variables mediante un índice para usar un bucle for. Este bucle, en su encabezado, hace lo siguiente:

- Declara una variable entera i que empieza en 0.
- Comprueba si la condición i < 2 se cumple (es decir, mientras i sea menor que 2).
- Si la condición es verdadera (distinta de 0), ejecuta las instrucciones dentro del bucle. Aquí la condición es que i sea menor que 2; una vez que i sea igual o mayor que 2, el bucle terminará.
- Al terminar cada ciclo, ejecuta la última instrucción del encabezado: i = i + 1. Aquí se indica que al valor de i se le va a asignar su valor anterior más uno, logrando incrementos de uno en uno. Podrían ser de dos en dos o incrementos variables; todo depende del número que le sumes. Si observas el encabezado del segundo bucle, verás que ya no se usa i = i + 1, sino i++. Esto solo es una forma más corta y legible de indicar que la variable debe incrementarse en 1.

Gracias a esto, podemos recorrer de manera secuencial todas las posiciones del arreglo usando i como índice.
Así, en cada repetición se accede a la siguiente variable de Entrada o Peso sin tener que escribir cada línea por separado.

Una vez declarado el bucle for, se agrupan las instrucciones que se van a repetir mediante llaves, igual que agrupamos las instrucciones dentro de la función main. Cuando el bloque contiene una única instrucción, las llaves se pueden omitir.

Ahora presta atención a lo que está sucediendo en el segundo bucle.
Iniciamos el valor de ponderacion con el valor de Sesgo, ya que este siempre se va a agregar a la suma independientemente de las entradas que reciba. Luego, mediante el bucle recorremos los pesos y las entradas para hacer cada multiplicación individual. Después puedes observar un operador nuevo: +=. Este operador es un incremento, similar a lo que vimos con el índice i, con la diferencia de que cuando el incremento es distinto de uno (como ocurre aquí), se utiliza += y se especifica el valor del incremento.
En nuestro caso, este incremento es el resultado de la multiplicación de la entrada por su peso, y estos valores se van sumando a ponderacion en cada ciclo.

Así, con pocas líneas, se define un comportamiento que sería mucho más largo si tuvieras que escribir cada operación de manera individual.

Ya has automatizado el comportamiento de ejecución de una neurona, pero aún nos falta la parte más interesante de todo esto: lograr que aprenda.
En lugar de establecer los valores de los pesos y el sesgo de manera manual para obtener distintos comportamientos, es momento de hacer el código con el cual podrá ajustar estos valores en función de la tabla de verdad que le demos como muestra, y así la neurona logrará imitarla.

Ahora vas a preparar el terreno para que la neurona pueda aprender.
En lugar de ingresar manualmente las entradas cada vez, vamos a crear un banco de pruebas que contenga todas las combinaciones posibles de entradas.
Para eso, conocerás una herramienta más del lenguaje C: las matrices, que no son más que arreglos que contienen otros arreglos. También vamos a usar un bucle para recorrer toda la lista.

En este ejemplo, crearemos una matriz con 4 filas y 3 columnas.
Cada fila representa, en sus dos primeras columnas, las entradas de la tabla de verdad, y la última es el resultado de una operación lógica específica.
Prepararemos nuestra tabla para definir una operación AND, la cual regresa verdadero cuando ambas entradas lo son.
A su vez, vamos a establecer los valores de los pesos y el sesgo en 0, ya que partiremos de una neurona limpia para poder entrenarla.

Veamos cómo se implementa:

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={0 , 0};

float Sesgo= 0;

int main(){

    int tabla[4][3]={
        {0 , 0 , 0},
        {0 , 1 , 0},
        {1 , 0 , 0},
        {1 , 1 , 1}
    };

    for( int i= 0 ; i < 4 ; i++){
        for( int j= 0 ; j < 2 ; j++)
            Entrada[j]= tabla[i][j];
    }

    for( int i= 0 ; i < 2 ; i++){
        printf( "Entrada %i: " , i );
        scanf( "%i" , &Entrada[i] );
        Entrada[i]= !!Entrada[i];
    }

    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
    Salida= ponderacion >= 0;

    printf( "Salida: %i\n" , Salida );
}
```

Primero, se declaró una matriz llamada tabla, donde cada fila contiene una de las combinaciones posibles de entradas binarias y su resultado esperado. Esta estructura es equivalente a una tabla de verdad completa.

Dentro del bucle que recorre toda la lista, se ha anidado otro bucle que cumple una función similar al que se usó antes para cargar los valores en las entradas desde scanf, pero en este caso los valores se cargarán desde la matriz que creamos como tabla de verdad.
Observa que el bucle interno utiliza un índice llamado j: esto permite recorrer tabla tanto en la cantidad de pruebas listadas como en los elementos individuales de cada prueba, usando los incrementos de los dos índices.

Con esto, ya tienes un banco de pruebas automatizado que puede tomar una lista de entradas predefinidas.

Antes de continuar, dado que tendremos que repetir el código que hace las operaciones internas de la neurona, vamos a agrupar estas instrucciones dentro de una función personalizada:

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={0 , 0};

float Sesgo= 0;

int activar_neurona(){
    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
    return ponderacion >= 0;
}
int main(){

    int tabla[4][3]={
        {0 , 0 , 0},
        {0 , 1 , 0},
        {1 , 0 , 0},
        {1 , 1 , 1}
    };

    for( int i= 0 ; i < 4 ; i++){
        for( int j= 0 ; j < 2 ; j++)
            Entrada[j]= tabla[i][j];
        Salida= activar_neurona();
    }

    for( int i= 0 ; i < 2 ; i++){
        printf( "Entrada %i: " , i );
        scanf( "%i" , &Entrada[i] );
        Entrada[i]= !!Entrada[i];
    }

    Salida= activar_neurona();

    printf( "Salida: %i\n" , Salida );

    return 0;
}
```

Has creado tu primera función personalizada: activar_neurona().
Esta función se encarga de realizar la ponderación y la activación de la neurona en función de los valores de las entradas.

Veamos cuál es su estructura:

La función se ha declarado como tipo int. A diferencia de las variables (donde el tipo de dato indica qué puedes guardar en ellas), en una función indica qué tipo de dato devuelve una vez que ha terminado su ejecución.
Ese valor será el que esté asignado en la instrucción return, la cual finaliza la ejecución de la función y entrega el resultado al bloque de código que la llamó.

Ahora que ya conoces la instrucción return, observa la última línea que se agregó en la función main().
main también es de tipo int, lo que implica que puede devolver un valor. Por convención, se considera una buena práctica agregar la instrucción return 0;, que termina la ejecución del programa y le devuelve un valor al sistema operativo.
Un valor 0 indica que el programa terminó sin problemas. Otros valores distintos de cero se pueden usar para señalar errores específicos que pudieron surgir mientras el programa estaba activo.

Si recuerdas, al principio de este módulo te comenté que pueden existir distintas funciones de activación.
Así que, si ya estamos separando nuestro código en funciones que realizan tareas específicas, no sería mala idea separar la función de activación de la función activar_neurona().
En los próximos módulos, cuando utilicemos otras funciones de activación, te mostraré cómo reemplazarlas de manera automática dentro de activar_neurona().

Veamos cómo queda el código:

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={0 , 0};

float Sesgo= 0;

int activacion_booleana( float x ){
    return x >= 0;
}

int activar_neurona(){
    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
   return activacion_booleana( ponderacion );
}

int main(){

    int tabla[4][3]={
        {0 , 0 , 0},
        {0 , 1 , 0},
        {1 , 0 , 0},
        {1 , 1 , 1}
    };

    for( int i= 0 ; i < 4 ; i++){
        for( int j= 0 ; j < 2 ; j++)
            Entrada[j]= tabla[i][j];
        Salida= activar_neurona();
    }

    for( int i= 0 ; i < 2 ; i++){
        printf( "Entrada %i: " , i );
        scanf( "%i" , &Entrada[i] );
        Entrada[i]= !!Entrada[i];
    }

    Salida= activar_neurona();

    printf( "Salida: %i\n" , Salida );

    return 0;
}
```

Permíteme explicarte el uso de los paréntesis en una función:

Podrás ver que en activacion_booleana() se hace la declaración de una variable de tipo float llamada x.
Esto indica que esta función debe recibir un valor de tipo float cuando se quiera utilizar. Después, emplea ese valor dentro de la función y devuelve un valor nuevo (en este caso, un int), que corresponde al resultado de la comparación x >= 0.

Con esta estructura que diseñamos en activacion_booleana(), podemos usarla dentro de activar_neurona(). Esta última calcula la ponderación de las entradas y el sesgo, guarda el resultado en su variable correspondiente, y ese valor se pasa como argumento al llamar a activacion_booleana(). Esta hace su cálculo y devuelve un resultado que se pasa directamente a la instrucción return de activar_neurona().

Como ves, el funcionamiento no cambió, solo la forma en que lo describes y organizas.

Un detalle importante a destacar es que en C no puedes utilizar una función que no haya sido declarada previamente al punto donde pretendes emplearla.
En otras palabras, si activacion_booleana() se va a usar dentro de activar_neurona(), debe aparecer más arriba en el código.

El siguiente paso del entrenamiento es revisar cuánto se ha equivocado el resultado de la neurona, comparándolo con el valor esperado en la tabla de ejemplo (ubicado en su tercera columna, que corresponde al índice 2).

Mira cómo se implementa:

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={0 , 0};

float Sesgo= 0;

int activacion_booleana( float x ){
    return x >= 0;
}

int activar_neurona(){
    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
   return activacion_booleana( ponderacion );
}

int main(){

    int tabla[4][3]={
        {0 , 0 , 0},
        {0 , 1 , 0},
        {1 , 0 , 0},
        {1 , 1 , 1}
    };

    for( int i= 0 ; i < 4 ; i++){
        for( int j= 0 ; j < 2 ; j++)
            Entrada[j]= tabla[i][j];
        Salida= activar_neurona();
        int error= tabla[i][2] - Salida;
    }

    for( int i= 0 ; i < 2 ; i++){
        printf( "Entrada %i: " , i );
        scanf( "%i" , &Entrada[i] );
        Entrada[i]= !!Entrada[i];
    }

    Salida= activar_neurona();

    printf( "Salida: %i\n" , Salida );

    return 0;
}
```

Como ves, el cálculo del error solo consiste en una resta:
el valor esperado en la tabla de ejemplo menos el resultado de la neurona.

Si la neurona devuelve un resultado más pequeño que el valor esperado, el error será positivo.
Si es mayor, el error será negativo.
Si son iguales, el error será cero.

El signo del error es importante, porque indica si los valores de los pesos y el sesgo deben incrementarse o disminuirse para acercar la salida de la neurona al resultado esperado en la tabla de muestra.

Ahora que ya podemos saber qué tan equivocada está nuestra neurona, hace falta usar ese error para ajustar, de manera individual, cada peso y el sesgo.

Para esto, vas a necesitar una nueva variable: la tasa de aprendizaje.
Si el signo del error indica si el ajuste se debe hacer hacia arriba o hacia abajo, la tasa de aprendizaje define qué tan grandes serán los pasos de cada ajuste.

Si usas un valor muy grande, es posible que la neurona nunca logre estabilizarse, porque se pasa del valor correcto y sigue oscilando.
Si es muy pequeño, tardará más en llegar al ajuste adecuado, pero los cambios serán más finos y precisos.

Aquí tienes el ejemplo:

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={0 , 0};

float Sesgo= 0;

int activacion_booleana( float x ){
    return x >= 0;
}

int activar_neurona(){
    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
   return activacion_booleana( ponderacion );
}

int main(){

    int tabla[4][3]={
        {0 , 0 , 0},
        {0 , 1 , 0},
        {1 , 0 , 0},
        {1 , 1 , 1}
    };

    float tasa_aprendizaje= 0.1;
    for( int i= 0 ; i < 4 ; i++){
        for( int j= 0 ; j < 2 ; j++)
            Entrada[j]= tabla[i][j];
        Salida= activar_neurona();
        int error= tabla[i][2] - Salida;
        Sesgo+= error * tasa_aprendizaje;
        for( int j= 0 ; j < 2 ; j++)
            Peso[j]+= error * tasa_aprendizaje * Entrada[j];
    }

    for( int i= 0 ; i < 2 ; i++){
        printf( "Entrada %i: " , i );
        scanf( "%i" , &Entrada[i] );
        Entrada[i]= !!Entrada[i];
    }

    Salida= activar_neurona();

    printf( "Salida: %i\n" , Salida );

    return 0;
}
```

Y así, has terminado el código que entrena a la neurona.

Para lograr este efecto “mágico”, se toma el cálculo del error y se multiplica por la tasa de aprendizaje (en este ejemplo, 0.1).
El resultado se asigna al sesgo usando el operador +=.

Para los pesos se hace un proceso similar, pero también se tiene en cuenta el valor de la entrada que recibió en ese momento.
Esto último es importante: si la entrada valía 0, ese peso no se modifica (porque todo número multiplicado por 0 es 0).
En cambio, si la entrada valía 1, el peso sí se ajusta, aumentando o disminuyendo según el signo del error.

Con esto, ya tienes en tus manos el primer ejemplo funcional de aprendizaje automático que, aunque sencillo, ilustra claramente la lógica detrás de una neurona artificial.

Ahora solo nos falta agregar un bucle más. Con un solo paso por los ejemplos, la neurona se acercará al resultado esperado, pero no habrá ajustado completamente sus pesos. Para que esto ocurra, el proceso debe repetirse varias veces, de la misma forma que cuando estás aprendiendo una habilidad nueva, como la mecanografía.

Aquí aprenderás un bucle distinto al for: el do while, que se traduce como “haz mientras”. Aunque se comporta de manera similar al for, tiene ciertas sutilezas que los diferencian. No entraré en detalle aquí, para eso existen cursos especializados en programación.

Para controlar este bucle tendrás que crear un par de variables más:

- Un acumulador de errores, que contará los errores en cada intento. Esto servirá para detectar cuándo la neurona ha “aprendido” la operación y debe terminar el entrenamiento.
- Un contador de intentos, que permitirá establecer un número máximo de intentos. Así evitamos que el programa se quede atrapado infinitamente intentando entrenar una operación que no logra resolver, por más ajustes que haga.

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={0 , 0};

float Sesgo= 0;

int activacion_booleana( float x ){
    return x >= 0;
}

int activar_neurona(){
    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
   return activacion_booleana( ponderacion );
}

int main(){

    int tabla[4][3]={
        {0 , 0 , 0},
        {0 , 1 , 0},
        {1 , 0 , 0},
        {1 , 1 , 1}
    };

    int epoca= 0;
    do{
        epoca++;
        int error_total= 0;
        float tasa_aprendizaje= 0.1;
        for( int i= 0 ; i < 4 ; i++){
            for( int j= 0 ; j < 2 ; j++)
                Entrada[j]= tabla[i][j];
            Salida= activar_neurona();
            int error= tabla[i][2] - Salida;
            Sesgo+= error * tasa_aprendizaje;
            for( int j= 0 ; j < 2 ; j++)
                Peso[j]+= error * tasa_aprendizaje * Entrada[j];
            error_total+= !!error;
        }
    } while( epoca < 1000 && error_total );

    for( int i= 0 ; i < 2 ; i++){
        printf( "Entrada %i: " , i );
        scanf( "%i" , &Entrada[i] );
        Entrada[i]= !!Entrada[i];
    }

    Salida= activar_neurona();

    printf( "Salida: %i\n" , Salida );

    return 0;
}
```

Algunos detalles sobre el control del bucle de intentos:

- Como mencioné, se usa el bucle do while. Este bucle ejecuta sus instrucciones al menos una vez. Luego, evalúa la condición que aparece entre los paréntesis tras el while. Si el resultado es distinto de cero, vuelve a ejecutarse; si es cero, termina.
- La condición del ejemplo dice: “mientras el número de intentos sea menor que 1000 y haya al menos un error en el conjunto de ejemplos”. Al usar &&, ambos valores deben ser distintos de cero para que el bucle continúe.
- La variable epoca se inicia en 0 y se incrementa con epoca++ al comienzo de cada ciclo.
- El acumulador error_total se reinicia en 0 en cada ciclo. Luego, para cada prueba individual, sumamos !!error. La doble negación convierte el error en 1 si es distinto de cero, o en 0 si no hay error. Esto es importante, porque el error puede ser negativo o positivo, y sumar directamente el valor del error podría falsear el conteo.

Ya tienes un código funcional con el que puedes empezar a experimentar. Puedes cambiar los valores de la tercera columna de la matriz de pruebas tabla para entrenar la neurona con otras operaciones. Te recomiendo apoyarte en las tablas del Módulo 0 del taller para tus pruebas.

Ahora que el código ya hace lo que debería, podemos mostrar información más clara y organizada:

El siguiente ejemplo agrega varias instrucciones de impresión que permiten:

- Mostrar la cantidad de intentos (épocas) que le tomó entrenar a la neurona.
- Imprimir el valor final de cada peso después del entrenamiento, con dos decimales de precisión.
- Mostrar una tabla de verdad que resume la operación que aprendió.

En el bloque donde se imprimen los pesos, se usa el formato %f, que a diferencia de %i, sirve para imprimir números con punto decimal. Además, se utiliza el carácter \t para crear una separación con tabulaciones entre cada columna, facilitando la lectura.

Por último, se imprime una tabla con el encabezado fijo | A | B | S | y, debajo, el resultado de cada combinación de entradas, aprovechando la carga automática de los datos como se hizo durante el entrenamiento.

``` C
#include <stdio.h>

int Entrada[2];

int Salida;

float Peso[]={0 , 0};

float Sesgo= 0;

int activacion_booleana( float x ){
    return x >= 0;
}

int activar_neurona(){
    float ponderacion= Sesgo;
    for( int i= 0 ; i < 2 ; i++)
        ponderacion+= Entrada[i] * Peso[i];
   return activacion_booleana( ponderacion );
}

int main(){

    int tabla[4][3]={
        {0 , 0 , 0},
        {0 , 1 , 0},
        {1 , 0 , 0},
        {1 , 1 , 1}
    };

    int epoca= 0;
    do{
        epoca++;
        int error_total= 0;
        float tasa_aprendizaje= 0.1;
        for( int i= 0 ; i < 4 ; i++){
            for( int j= 0 ; j < 2 ; j++)
                Entrada[j]= tabla[i][j];
            Salida= activar_neurona();
            int error= tabla[i][2] - Salida;
            Sesgo+= error * tasa_aprendizaje;
            for( int j= 0 ; j < 2 ; j++)
                Peso[j]+= error * tasa_aprendizaje * Entrada[j];
            error_total+= !!error;
        }
    } while( epoca < 1000 && error_total );
    printf( "\nIntentos: %i\n" , epoca );
    for( int i= 0 ; i < 2 ; i++ )
        printf( "Peso %i: %.2f\t" , i + 1 , Peso[i] );

    printf( "\n| A | B | S |\n" );
    for( int i= 0 ; i < 4 ; i++){
        for( int j= 0 ;  j < 2 ; j++)
            Entrada[j]= tabla[i][j];
        Salida= activar_neurona();
        printf( "| %i | %i | %i |\n" , Entrada[0] , Entrada[1] , Salida );
    }
    printf( "\n" );
    
    return 0;
}
```

Notas finales:

- El formato %.2f muestra los números con dos decimales.
- Recuerda que en C debes poner siempre ; al final de cada instrucción.
- Este programa ahora imprime un resumen ordenado y es más fácil de interpretar.
- Recuerda compilar cada vez que hagas modificaciones en el codigo para que estos tengan efecto.

Este módulo ha terminado. Si has tenido la paciencia y la dedicación de llegar hasta aquí, permíteme ovacionarte.
Sé que no fue un camino sencillo, pero para que tomes conciencia de lo que has conseguido, te daré un recuento de todo lo que has aprendido.

Sobre inteligencia artificial has aprendido:

- Qué elementos componen una neurona artificial.
- Cómo esta modifica su comportamiento ajustando los valores de los pesos y el sesgo, y no cambiando el código.
- Crear un banco de ejemplos que el proceso de entrenamiento utiliza para entrenar a la neurona
- Cómo logra “aprender” de manera automática calculando su error en función de los datos que le damos como muestra, y cómo utiliza este error para ajustar sus valores.

Una inteligencia artificial no es más que muchas de estas neuronas conectadas entre sí, donde las salidas de unas pasan como entradas de las que siguen.
Así que, con esto, ya tienes toda la comprensión básica de cómo funciona la IA.

Sobre programación en lenguaje C has aprendido:

- Crear variables que utilizas para almacenar valores.
- Agrupar estas variables mediante arreglos, para evitar hacer listas interminables de ellas.
- Hacer bucles para recorrer los arreglos y realizar operaciones repetitivas.
- Crear funciones para agrupar instrucciones que se van a repetir durante el diseño del código.
- Mostrar información en pantalla usando printf.
- Leer datos desde el teclado usando scanf.
- Incluir bibliotecas, como hicimos con stdio.h.

Antes de continuar con el siguiente módulo, te invito a intentar por ti mismo entrenar tu neurona para que resuelva XOR.
Te darás cuenta de que, por más intentos que hagas, nunca llega a entrenarse correctamente.
Prueba deducir por ti mismo, con las herramientas que ya tienes, por qué sucede esto y trata de proponer una solución que te permita lograrlo.

Ahora puedes imprimir tu código y enmarcarlo, pegarlo en el refrigerador, o tomarle una captura de pantalla y usarlo de fondo de escritorio.
Siéntete orgulloso de lo que has logrado, porque no es poca cosa.

Te espero en el siguiente módulo, donde seguiremos extendiendo este mismo código para resolver finalmente XOR.
