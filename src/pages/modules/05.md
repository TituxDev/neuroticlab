---
layout: layouts/views/general.njk
title: Estructurando la inteligencia
---

# Módulo 5 - Estructurando la inteligencia

## Introducción

Estamos en la recta final del entendimiento de las redes neuronales. Pero antes de continuar, recordemos dónde nos quedamos en el módulo anterior:

#### NeuroTIC.h

``` C
/*========BIBLIOTECAS========*/
#include <math.h>
/*========ACTIVACION=========*/
float activacion_booleana( float x ){
    return x >= 0;
}
float activacion_booleana_d( float x ){
    return 1;
}

float activacion_sigmoide( float x ){
    return 1 / ( 1 + exp( - x ) );
}
float activacion_sigmoide_d( float x ){
    return activacion_sigmoide( x ) * ( 1 - activacion_sigmoide( x ) );
}

float ( *activacion[][2] )( float )={
    { activacion_booleana , activacion_booleana_d },
    { activacion_sigmoide , activacion_sigmoide_d }
};
/*=======DEFINICIONES========*/
struct neurona{
    float *Entrada[2];
    float Salida;
    float Peso[2];
    float Sesgo;
    int activacion;
};
/*=========CALCULAR==========*/
float ponderacion( struct neurona N ){
    float p= N.Sesgo;
    for( int i= 0; i < 2 ; i++ )
        p+= *N.Entrada[i] * N.Peso[i];
    return p;
}

float evaluar_neurona( struct neurona N ){
   return activacion[N.activacion][0]( ponderacion( N ) );
}
/*=========ENTRENAR==========*/
int entrenar(  struct neurona *N , float entradas[4][2] , float resultados[4] , float tasa_aprendizaje , float error_permitido , int max_intentos  ){
    float error;
    float delta;
    float delta_oculta;
    float error_total;
    int epoca= 0;
    do{
        error_total= 0;
        for( int i= 0 ; i < 4 ; i++ ){
            for( int j= 0; j < 2 ; j++ )
                *N[0].Entrada[j]= entradas[i][j];
            for( int j= 0 ; j < 3 ; j++ )
                N[j].Salida= evaluar_neurona( N[j] );
            error= resultados[i] - N[2].Salida;
            error_total= fmax( error_total , fabs( error ) );
            delta= error * activacion[N[2].activacion][1]( ponderacion( N[2]) );
            N[2].Sesgo+= delta * tasa_aprendizaje;
            for( int j= 0 ; j < 2 ; j++ )
                N[2].Peso[j]+= delta * tasa_aprendizaje * entradas[i][j];
            for( int j= 0; j < 2 ; j++ ){
                delta_oculta= delta * N[2].Peso[j] * activacion[N[j].activacion][1]( ponderacion( N[j] ) );
                N[j].Sesgo+= tasa_aprendizaje * delta_oculta;
                for( int k= 0; k < 2; k++ )
                    N[j].Peso[k]+= tasa_aprendizaje * delta_oculta * *N[j].Entrada[k];
            }
        }
    } while( ++epoca < max_intentos && error_total > error_permitido );
    return epoca;
}
```

#### NeuroTIC.c

``` C
/*========BIBLIOTECAS========*/
#include <stdio.h>
#include "NeuroTIC.h"
/*=========VARIABLES=========*/
float Entrada[2];
float Salida;

struct neurona N[]= {
    {
    .Entrada= { &Entrada[0] , &Entrada[1] },
    .activacion= 1
    },
    {
    .Entrada= { &Entrada[0] , &Entrada[1] },
    .activacion= 1
    },
    {
    .Entrada= { &N[0].Salida , &N[1].Salida },
    .activacion= 1
    }
};
/*=========PRINCIPAL=========*/
int main(){
    /* ENTRADAS */
    float tabla[4][2]={
        { 0 , 0 },
        { 0 , 1 },
        { 1 , 0 },
        { 1 , 1 }
    };
    /* MUESTRAS */
    float resultado[]= { 0 , 1 , 1 , 0 };
    /* ENTRENAMIENTO */
    printf( "\nEntrenamiento Intentos: %i\n" , entrenar( N , tabla , resultado , 0.1, 0.0, 1000 ) );
    /* CALCULAR E IMPRIMIR */
        printf( "\n\n| A | B | S |\n" );
        for( int i= 0 ; i < 4 ; i++ ){
            for( int j= 0 ;  j < 2 ; j++ )
                Entrada[j]= tabla[i][j];
            for( int j= 0; j < 3 ; j++ )
                N[j].Salida= evaluar_neurona( N[j] );
            Salida= N[2].Salida;
            printf( "| %.0f | %.0f | %.0f |\n" , Entrada[0] , Entrada[1] , Salida );
        }
        printf( "\n" );
    /* TERMINAR PROGRAMA */
    return 0;
}
```

Ahora ya cuentas con toda la teoría y las herramientas necesarias para construir una red y entrenarla con ejemplos concretos. Aprendiste a propagar el error desde la capa de salida hasta la capa de entrada, usando la derivada de la función sigmoide. Sin embargo, aún nos queda una última restricción por superar para romper el límite de las tres neuronas que hemos estado utilizando hasta ahora.

Esta vez, el obstáculo no es conceptual, sino técnico. Tiene que ver con cómo estamos declarando las entradas y los pesos dentro de la estructura de la neurona, y también con la forma en que estamos organizando las neuronas dentro de un arreglo. Pero antes de ver cómo solucionarlo, es importante entender por qué es un problema.

---

## Topología de una red neuronal artificial

El concepto de topología en las redes neuronales se refiere a cómo están organizadas las neuronas y cómo se conectan entre sí.

Una topología básica implica que cada neurona de una capa se conecta a todas las neuronas de la capa anterior. Esta es, de hecho, la topología que has utilizado hasta ahora: cada neurona de tu capa de entrada se conecta a cada una de las entradas disponibles, y la neurona de salida se conecta a todas las neuronas de la capa anterior.

Como hasta ahora solo has trabajado con dos entradas y dos neuronas intermedias, cada neurona tiene exactamente dos entradas. Pero ¿qué pasaría si tuvieras más entradas? ¿O si las capas intermedias tuvieran más neuronas?

Aquí es donde aparece la limitación: tu estructura de neurona está definida como *Entrada[2] y Peso[2]. Esto significa que solo puede manejar exactamente dos entradas. Si quisieras usar más, tendrías que definir una estructura diferente para cada caso.

En una red neuronal real, esto no es viable, ya que cada neurona puede tener una cantidad distinta de entradas, dependiendo de cuántas neuronas haya en la capa anterior. Es necesario, entonces, crear una estructura más flexible que se adapte dinámicamente a cualquier cantidad de entradas.

---

## Creadno entradas

Para poder lograr la flexibilidad que te propongo —y que te permitirá construir cualquier topología de red—, vas a conocer una nueva función de C llamada calloc. Esta función se encuentra definida en la biblioteca stdlib.h, así que lo primero será incluir dicha biblioteca en tu propia cabecera, para que esté disponible tanto en ella como en el código principal. Luego, haremos un cambio importante en la definición de la estructura de la neurona:

#### NeuroTIC.h

``` C
/*========BIBLIOTECAS========*/
#include <math.h>
#include <stdlib.h>
/*========ACTIVACION=========*/
/*=======DEFINICIONES========*/
struct neurona{
    int entradas;
    float **Entrada;
    float Salida;
    float *Peso;
    float Sesgo;
    int activacion;
};
/*=========ENTRENAR==========*/
```

Como puedes ver, ahora el atributo Entrada ya no es un arreglo estático, sino un puntero doble, lo cual nos permite apuntar a un arreglo de direcciones. Por otro lado, Peso ya no es un arreglo de tamaño fijo, sino un puntero simple, lo que nos permitirá crear su contenido dinámicamente.

Además, agregamos una nueva variable: entradas. Esta será muy útil porque nos permitirá definir cuántas entradas tendrá cada neurona de forma independiente.

Ya sabes que un puntero solo puede guardar una única dirección. Pero con la función calloc podemos pedirle al sistema operativo que nos reserve un bloque de memoria con una cierta cantidad de espacios, y luego nos devuelva la dirección de inicio de ese bloque. Esto es muy parecido a crear un arreglo durante la ejecución del programa.

Es muy importante que no utilices calloc sin tener dónde guardar la dirección que devuelve. Si la pierdes, no podrás acceder a ese bloque de memoria ni tampoco liberarlo después. Vamos a ver cómo se usa esta función en el código principal.

#### NeuroTIC.c

``` C
/*========BIBLIOTECAS========*/
#include <stdio.h>
#include "NeuroTIC.h"
/*=========PRINCIPAL=========*/
int main(){
/*=========VARIABLES=========*/
    float Entrada[2];
    float Salida;

    struct neurona N[]= {
        {
        .entradas= 2,
        .activacion= 1
        },
        {
        .entradas= 2,
        .activacion= 1
        },
        {
        .entradas= 2,
        .activacion= 1
        }
    };

    for( int i= 0 ; i < 3 ; i++ ){
        N[i].Entrada= calloc( N[i].entradas , sizeof( float * ) );
        N[i].Peso= calloc( N[i].entradas , sizeof( float ) );
    }

    for( int i= 0 ; i < 2 ; i++ )
        for( int j= 0 ; j < 2 ; j++ )
            N[i].Entrada[j]= &Entrada[j];

    for( int i= 0 ; i < 2 ; i++ )
        N[2].Entrada= &N[i].Salida;
    /* ENTRADAS */
    /* MUESTRAS */
    /* ENTRENAMIENTO */
    /* CALCULAR E IMPRIMIR */
    /* TERMINAR PROGRAMA */
}
```

Explicación del código:

- Como todas las funciones de tu biblioteca son independientes del código principal, lo primero que hacemos es mover la definición de main() justo después de incluir las bibliotecas.
- Luego eliminamos la inicialización manual de las direcciones en el atributo Entrada y la reemplazamos por la asignación del atributo entradas, que ahora nos permite definir cuántas tendrá cada neurona.
- Una vez creadas las estructuras, usamos un bucle para asignar memoria con calloc tanto a Entrada como a Peso.
- Después, otro par de bucles nos permite asignar las direcciones específicas a cada neurona, ya que no podemos usar llaves para inicializar estos atributos después de declararlos.

Antes de entender bien cómo funciona calloc, necesitas conocer otra herramienta básica de C: la función sizeof.

Ya hemos dicho que las variables son como cajas donde guardas números. Pero lo que no te he explicado aún es que esas cajas no tienen todas el mismo tamaño: una variable de tipo int ocupa una cierta cantidad de espacio en memoria, y una de tipo float ocupa una diferente.

La función sizeof te dice exactamente cuántos espacios (bytes) necesita un tipo de variable para guardarse en memoria. Por ejemplo, si usas:  
sizeof(float)  
Estás preguntando: ¿cuánto espacio ocupa una variable tipo float?

Ahora, cuando usamos calloc(cantidad, tamaño), lo que le estamos pidiendo a la computadora es que nos reserve cantidad × tamaño espacios de memoria, donde:

- cantidad es el número de elementos que queremos guardar, y
- tamaño es cuánto espacio ocupa cada uno (lo que nos dice sizeof).

Por ejemplo, en esta línea:  
N[i].Peso = calloc(N[i].entradas, sizeof(float));  
Estamos diciendo: reserva un bloque de memoria capaz de guardar N[i].entradas valores tipo float.

Y en esta otra:  
N[i].Entrada = calloc(N[i].entradas, sizeof(float *));  
Estamos reservando memoria para N[i].entradas direcciones, cada una de las cuales apunta a una variable tipo float.

#### NeuroTIC.c

``` C
/*========BIBLIOTECAS========*/
#include <stdio.h>
#include "NeuroTIC.h"
/*=========PRINCIPAL=========*/
int main(){
/*=========VARIABLES=========*/
    /* ENTRADAS */
    /* MUESTRAS */
    /* ENTRENAMIENTO */
    /* CALCULAR E IMPRIMIR */
    /* TERMINAR PROGRAMA */
    for( int i= 0 ; i < 3 ; i ++ ){
        free( N[i].Entrada );
        free( N[i].Peso );
    }
    return 0;
}
```

Cuando se utiliza herramientas de creacion de memoria dinamica como calloc, una vez que este espacio ya no es necesario, se rqeuiere liberar manualmente la memoria, ya que una vez terminado el programa, el sistema seguira marcando ese espacio de memoria como ocuapdo y no podra utilizarse, esto puede ocasionar problemas en tu computadora.

Para liberar la memoria se utiliza la funcion free y se le indica que direccion debe liberar, es por esto la importancia de siempre mantener un puntero con dicha direccion, ya que si no, no hay manera de acceder a ese espacio para liberalo, como vez, en este bucle final se esta liberando el espacio asignado a Entrada y Peso de cada una de las neuronas.

Ahora puedes compilar y ejecutar tu programa para asegurarte que sigue trabajando correctamente.

---

## Creando topologías

Hasta ahora hemos utilizado un arreglo simple de tres neuronas porque la red era pequeña: dos neuronas en la primera capa y una en la segunda. En este caso, es fácil de manejar y no representa ninguna complicación.

Sin embargo, cuando tu red empieza a crecer, se vuelve muy difícil controlar a qué capa pertenece cada neurona y cómo se deben conectar entre sí. Además, si quieres que cada capa tenga un número distinto de neuronas, el manejo de los índices se vuelve cada vez más complejo y propenso a errores.

Por eso, a partir de este punto vas a rediseñar la estructura de tu red neuronal. Vas a crear una nueva estructura que no solo contenga las neuronas, sino que también describa la topología completa de la red: cuántas capas tiene, cuántas neuronas hay por capa y cómo se conectan entre sí. Esta estructura utilizará punteros dinámicos para que puedas construir redes de cualquier tamaño y forma.

#### NeuroTIC.h

``` C
/*========BIBLIOTECAS========*/
/*========ACTIVACION=========*/
/*=======DEFINICIONES========*/
struct neurona{
    int entradas;
    float **Entrada;
    float Salida;
    float *Peso;
    float Sesgo;
    int activacion;
};

struct red{
    int entradas;
    float **Entrada;
    int capas;
    int *neuronas;
    struct neurona **N;
    float ***buffer;
    float **Salida;
}
/*=========ENTRENAR==========*/
```
Veamos qué atributos tiene esta nueva estructura:

- entradas: Aquí se define la cantidad de valores de entrada que tendrá la red.
- *Entrada: Este será un arreglo de punteros que servirá para comunicar la red con el exterior. Es decir, no guarda los datos directamente, solo apunta a ellos.
- capas: Será el valor que indica cuántas capas tiene la red en total, incluyendo la capa de entrada, las ocultas (si las hay) y la capa de salida.
- *neuronas: Se convertirá en un arreglo donde cada posición indica cuántas neuronas hay en cada capa. Por ejemplo, neuronas[0] corresponde a la capa de entrada, neuronas[1] a la siguiente, y así sucesivamente.
- **N: Este doble puntero se utiliza de forma distinta a como se hizo con Entrada. En lugar de ser solo un arreglo de punteros, será una matriz dinámica donde cada fila representa una capa y cada elemento de esa fila es una neurona. Así podrás posicionar las neuronas organizadas por capa y facilitar la construcción de la topología de la red.
- ***buffer: ¿Un puntero triple? ¿Me he vuelto loco? No, ya lo estaba.  
Este puntero tiene la función de evitar que dupliques arreglos para conectar las neuronas intermedias con las salidas de las capas anteriores. El buffer será una matriz de punteros: cada fila representa una capa intermedia, y dentro de ella hay punteros que apuntan directamente a las salidas de la capa anterior. Las entradas de cada neurona se conectarán a este arreglo de punteros.
- **Salida: Es un puntero doble similar a Entrada. Hasta ahora has trabajado con redes que solo tenían una salida, pero si más adelante agregas varias, este arreglo te permitirá devolver fácilmente todas las salidas sin complicaciones, ya que cada puntero apunta directamente al campo Salida de una neurona en la última capa.

Una vez definida la estructura, vamos a declarar una red con 2 entradas, 2 neuronas en la primera capa y 1 en la segunda (justo como hemos venido trabajando).

#### NeuroTIC.c

``` C
/*========BIBLIOTECAS========*/
/*=========PRINCIPAL=========*/
/*=========VARIABLES=========*/
    struct red R={
        .entradas= 2,
        .capas= 2,
    };

    R.neuronas= calloc( R.capas , sizeof( int ) );
    R.neuronas[0]= 2;
    R.neuronas[1]= 1;

    R.Entrada= calloc( R.entradas , sizeof( float * ) );

    R.N= calloc( R.capas , sizeof( struct neurona * ) );
    for( int i= 0 ; i < R.capas ; i++ )
        R.N[i]= calloc( R.neuronas[i] , sizeof( struct neurona ) );

    for( int i= 0 ; i < R.neuronas[0] ; i++ )
        R.N[0][i].Entrada= R.Entrada;
    
    R.Salida= calloc( R.neuronas[R.capas - 1] , sizeof( float * ) );
    for( int i= 0 ; i < R.neuronas[R.capas - 1] ; i++ )
        R.Salida[i]= &R.N[R.capas -1][i].Salida;
    
    R.buffer= calloc( R.capas - 1 ,  sizeof( float ** ) );
    for( int i= 0 ; i < R.capas - 1 ; i++ ){
        R.buffer[i]= calloc( R.neuronas[i] , sizeof( float * ) );
        for( int j= 0 ; j < R.neuronas[i] ; j++ )
            R.buffer[i][j]= &R.N[i][j].Salida;
    }

    for( int i= 0 ; i < R.capas - 1 ; i++ )
        for( int j= 0 ; j < R.neuronas[i + 1] ; j++ )
            R.N[i + 1][j].Entrada= R.buffer[i];

    for( int i= 0 ; i < R.neuronas[0] ; i++ )
        R.N[0][i].entradas= R.entradas;
    for( int i= 1 ; i < R.capas ; i++ )
        for( int j= 0 ; j < R.neuronas[i] ; j++ )
            R.N[i][j].entradas= R.neuronas[i - 1];

    for( int i= 0 ; i < R.capas ; i++ )
        for( int j= 0 ; j < R.neuronas[i] ; j++ )
            R.N[i][j].Peso= calloc( R.N[i][j].entradas , sizeof( float ) );
    /* ENTRADAS */
    /* MUESTRAS */
    /* ENTRENAMIENTO */
    /* CALCULAR E IMPRIMIR */
    /* TERMINAR PROGRAMA */
```

Sí, ¡el código ha crecido! Pero no te preocupes. Este bloque pronto se convertirá en una función reutilizable dentro de tu biblioteca. Así, cada vez que quieras crear una red, solo tendrás que decir cuántas entradas tendrá, cuántas capas usará, y cuántas neuronas habrá en cada capa.

Veamos paso a paso cómo se construye esta red neuronal:

1. Inicia declarando una estructura red llamada R, donde defines dos valores fundamentales: la cantidad de entradas que recibirá del exterior, y la cantidad total de capas que tendrá la red, incluyendo tanto la capa de entrada como la de salida. Esta información será clave para crear toda la topología.
2. Se reserva memoria para el arreglo neuronas, que indica cuántas neuronas tendrá cada capa. En este ejemplo, asignamos 2 neuronas para la primera capa (la de entrada) y 1 para la segunda (la de salida). Como verás, este arreglo es tan largo como el número de capas.
3. Se reserva el espacio para el arreglo de punteros Entrada, que servirá para comunicar la red con el mundo exterior. Este arreglo no contiene valores, sino direcciones. Cada posición apuntará a una variable de entrada individual.
4. Se construye la matriz N que contendrá las neuronas organizadas por capa. Primero se crea un arreglo de punteros a estructuras neurona, donde cada puntero representará una capa. Luego, para cada capa, se reserva un arreglo de estructuras neurona de acuerdo a cuántas se necesitan, según el arreglo neuronas.
5. Se conectan las entradas externas a la primera capa de la red. Esto se logra cargando las direcciones almacenadas en R.Entrada dentro del atributo Entrada de cada neurona en la capa 0. Así, todas las neuronas de la primera capa estarán leyendo directamente las entradas definidas fuera de la red.
6. Se prepara la salida de la red. En lugar de tener una única salida, se utiliza un arreglo de punteros dobles llamado Salida, donde se almacenan las direcciones de las salidas de todas las neuronas de la última capa. Para acceder a esta capa correctamente se usa el índice R.capas - 1, ya que los arreglos inician en cero.
7. Se construye el buffer que conectará las capas intermedias. Primero se reserva un arreglo de punteros dobles, con un tamaño de R.capas - 1, para cubrir todos los espacios entre capas. Luego, para cada una de esas filas, se reserva un arreglo de punteros que apuntan a la salida de cada neurona de la capa anterior. Este buffer actúa como un puente: guarda punteros a las salidas de una capa para que las siguientes puedan usarlas como entrada.
8. Se recorre la matriz N para conectar cada neurona con su correspondiente entrada. Las neuronas de la capa 0 ya están conectadas a las entradas externas, pero todas las demás se conectan al buffer de la capa anterior. Así se establece automáticamente la conexión entre capas.
9. Se define cuántas entradas tendrá cada neurona. Las neuronas de la primera capa tomarán como número de entradas el valor R.entradas. Luego, capa por capa, cada neurona toma como número de entradas la cantidad de neuronas de la capa anterior. Esto asegura que cada neurona tenga exactamente un peso por cada entrada recibida.
10. Se reserva memoria para el arreglo de pesos Peso de cada neurona. Finalmente, una vez conocido cuántas entradas tendrá cada neurona, se utiliza calloc para crear su arreglo de pesos correspondiente. Así, cada peso estará vinculado directamente a una entrada, lista para ser entrenada.

Como puedes observar, solo los pasos 1 y 2 debes indicarlos manualmente, lo demas sucede en funcion de estos.

---

## Ajustando el codigo

Antes de ponernos guapos haciendo la funcion de construccion de la red, vamos a ajustar lo que ya tenemos para poder probar este nuevo codigo sin complicaciones.

Primero vamos a ajustar la funcion de entrenamiento para que reciba una estructura red completa en lugar de un arreglo de neuronas.

#### NeuroTIC.h

``` C
/*========BIBLIOTECAS========*/
/*========ACTIVACION=========*/
/*=======DEFINICIONES========*/
/*=========CALCULAR==========*/
/*=========ENTRENAR==========*/
int entrenar(  struct red *R , float entradas[4][2] , float resultados[4] , float tasa_aprendizaje , float error_permitido , int max_intentos  ){
    float error;
    float delta;
    float delta_oculta;
    float error_total;
    int epoca= 0;
    do{
        error_total= 0;
        for( int i= 0 ; i < 4 ; i++ ){
            for( int j= 0 ; j < Net->inputs ; j++ )
                Net->Entrada[j]= &entradas[i][j];
            for( int j= 0 ; j < R->capas ; j++ )
                for( int k= 0 ; k < R->neuronas[j] ; k++ )
                    R->N[j][k].Salida= evaluar_neurona( R->N[j][k] );
            error= resultados[i] - R->Salida[0];
            error_total= fmax( error_total , fabs( error ) );
            delta= error * activacion[N[2].activacion][1]( ponderacion( N[2]) );
            N[2].Sesgo+= delta * tasa_aprendizaje;
            for( int j= 0 ; j < 2 ; j++ )
                N[2].Peso[j]+= delta * tasa_aprendizaje * entradas[i][j];
            for( int j= 0; j < 2 ; j++ ){
                delta_oculta= delta * N[2].Peso[j] * activacion[N[j].activacion][1]( ponderacion( N[j] ) );
                N[j].Sesgo+= tasa_aprendizaje * delta_oculta;
                for( int k= 0; k < 2; k++ )
                    N[j].Peso[k]+= tasa_aprendizaje * delta_oculta * *N[j].Entrada[k];
            }
        }
    } while( ++epoca < max_intentos && error_total > error_permitido );
    return epoca;
}
```
